import React, { useState, useEffect } from 'react';
import { usePrivy } from '@privy-io/react-auth';
import { ethers } from 'ethers';

const CONTRACT_ADDRESS = "0x7d5C48A82E13168d84498548fe0a2282b9C1F16B";
const CONTRACT_ABI = [
  {"inputs":[{"internalType":"address","name":"minter","type":"address"}],
   "name":"getMintStats","outputs":[{"internalType":"uint256","name":"minterNumMinted","type":"uint256"},
   {"internalType":"uint256","name":"currentTotalSupply","type":"uint256"},
   {"internalType":"uint256","name":"maxSupply","type":"uint256"}],
   "stateMutability":"view","type":"function"},
  {"inputs":[],"name":"maxSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],
   "stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"minter","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"}],
   "name":"mintSeaDrop","outputs":[],"stateMutability":"payable","type":"function"},
  {"inputs":[],"name":"getPublicMintPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],
   "stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"","type":"address"}],
   "name":"maxMintPerWallet","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],
   "stateMutability":"view","type":"function"}
];

const HYPEREVM_RPC = "https://api.hyperliquid.xyz/evm";
const HYPEREVM_EXPLORER = "https://explorer.hyperliquid.xyz";

export default function NftMint() {
  const { privy, isLoaded } = usePrivy();

  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [contract, setContract] = useState(null);
  const [readOnlyContract, setReadOnlyContract] = useState(null);

  const [userAddress, setUserAddress] = useState(null);
  const [quantity, setQuantity] = useState(1);
  const [mintPrice, setMintPrice] = useState(ethers.BigNumber.from(0));
  const [maxPerWallet, setMaxPerWallet] = useState(10);
  const [userMintedCount, setUserMintedCount] = useState(0);
  const [maxRemaining, setMaxRemaining] = useState(0);
  const [totalSupply, setTotalSupply] = useState(0);
  const [maxSupply, setMaxSupply] = useState(0);

  const [status, setStatus] = useState({ message: '', type: '' });
  const [loading, setLoading] = useState(false);
  const [txLink, setTxLink] = useState('');

  // Initialize read-only contract
  useEffect(() => {
    const rpcProvider = new ethers.providers.JsonRpcProvider(HYPEREVM_RPC);
    const roContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, rpcProvider);
    setReadOnlyContract(roContract);
    updateSupply(roContract);
  }, []);

  // Update supply data every 15 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      if (readOnlyContract) updateSupply(readOnlyContract);
      if (contract && userAddress) updateUserData();
    }, 15000);
    return () => clearInterval(interval);
  }, [readOnlyContract, contract, userAddress]);

  const showStatus = (msg, type) => setStatus({ message: msg, type });
  const hideStatus = () => setStatus({ message: '', type: '' });

  const updateSupply = async (contractToUse) => {
    try {
      const stats = await contractToUse.getMintStats(ethers.constants.AddressZero);
      const currentTotal = parseInt(stats.currentTotalSupply.toString());
      const maxTotal = parseInt(stats.maxSupply.toString());
      setTotalSupply(currentTotal);
      setMaxSupply(maxTotal);
      setMaxRemaining(Math.max(0, maxTotal - currentTotal));
    } catch (err) {
      console.error("Supply update error:", err);
      showStatus("Error fetching total supply", "error");
    }
  };

  const updateUserData = async () => {
    if (!contract || !userAddress) return;
    try {
      const stats = await contract.getMintStats(userAddress);
      const minted = parseInt(stats.minterNumMinted.toString());
      setUserMintedCount(minted);

      const maxMint = await contract.maxMintPerWallet(userAddress);
      setMaxPerWallet(parseInt(maxMint.toString()));
    } catch (err) {
      console.error("User data error:", err);
    }
  };

  const connectWallet = async () => {
    if (!isLoaded) {
      showStatus("Privy not loaded. Refresh page.", "error");
      return;
    }

    try {
      showStatus("Initializing Privy wallet...", "info");
      const { provider: ethProvider } = await privy.embeddedWallet.create({
        chain: { type: 'evm', chainId: '0x3E6', rpcUrl: HYPEREVM_RPC }
      });

      const ethersProvider = new ethers.providers.Web3Provider(ethProvider.provider);
      const signer = ethersProvider.getSigner();
      setProvider(ethersProvider);
      setSigner(signer);

      const accounts = await ethProvider.provider.request({ method: 'eth_requestAccounts' });
      setUserAddress(accounts[0]);

      const nftContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
      setContract(nftContract);

      // Fetch price and user data
      const price = await nftContract.getPublicMintPrice();
      setMintPrice(price);
      await updateUserData();

      showStatus("Wallet connected!", "success");
      setTimeout(hideStatus, 3000);
    } catch (err) {
      console.error(err);
      showStatus("Wallet connection failed: " + (err.message || "Unknown error"), "error");
    }
  };

  const mintNFT = async () => {
    if (!contract || !userAddress) {
      showStatus("Connect wallet first", "error");
      return;
    }
    setLoading(true);
    showStatus(`Minting ${quantity} NFT(s)...`, "info");
    try {
      const tx = await contract.mintSeaDrop(userAddress, quantity, { value: mintPrice.mul(quantity) });
      const receipt = await tx.wait();
      setTxLink(`${HYPEREVM_EXPLORER}/tx/${receipt.transactionHash}`);
      showStatus(`Successfully minted ${quantity} NFT(s)!`, "success");
      setQuantity(1);
      await updateSupply(contract);
      await updateUserData();
    } catch (err) {
      console.error(err);
      showStatus("Mint failed: " + (err.message || "Unknown error"), "error");
    }
    setLoading(false);
  };

  const increaseQuantity = () => {
    const maxAllowed = Math.min(maxRemaining, maxPerWallet - userMintedCount);
    if (quantity < maxAllowed) setQuantity(quantity + 1);
  };
  const decreaseQuantity = () => {
    if (quantity > 1) setQuantity(quantity - 1);
  };

  const formattedPrice = mintPrice.isZero() ? "FREE" : `${ethers.utils.formatEther(mintPrice.mul(quantity))} ETH`;
  const progressPercent = maxSupply > 0 ? (totalSupply / maxSupply) * 100 : 0;

  return (
    <div style={{ maxWidth: 500, margin: 'auto', padding: 20, color: '#fff', fontFamily: 'Inter' }}>
      <h1>ðŸŽ¨ NFT Mint</h1>
      <p>{userAddress ? `Connected: ${userAddress.slice(0,6)}...${userAddress.slice(-4)}` : 'Connect your wallet to mint'}</p>
      {!userAddress && <button onClick={connectWallet}>Connect Wallet</button>}

      <div style={{ marginTop: 20 }}>
        <div>Total Supply: {totalSupply} / {maxSupply}</div>
        <div>Your Mints: {userMintedCount} / {maxPerWallet}</div>
        <div style={{ marginTop: 10, background: '#333', borderRadius: 10, height: 12, overflow: 'hidden' }}>
          <div style={{ width: `${progressPercent}%`, height: '100%', background: '#ff6600' }} />
        </div>
      </div>

      {userAddress && (
        <div style={{ marginTop: 20 }}>
          <div>
            <button onClick={decreaseQuantity} disabled={quantity<=1}>âˆ’</button>
            <span style={{ margin: '0 15px', fontSize: 20 }}>{quantity}</span>
            <button onClick={increaseQuantity} disabled={quantity >= Math.min(maxRemaining, maxPerWallet - userMintedCount)}>+</button>
          </div>
          <div style={{ marginTop: 10 }}>Price: {formattedPrice}</div>
          <button onClick={mintNFT} disabled={loading} style={{ marginTop: 15 }}>
            {loading ? 'Minting...' : 'Mint NFT'}
          </button>
          {txLink && <div style={{ marginTop: 10 }}><a href={txLink} target="_blank" rel="noopener noreferrer">View Transaction</a></div>}
        </div>
      )}

      {status.message && (
        <div style={{
          marginTop: 20,
          padding: 12,
          borderRadius: 8,
          textAlign: 'center',
          background: status.type==='success' ? 'rgba(0,255,100,0.1)' : status.type==='error' ? 'rgba(255,0,0,0.1)' : 'rgba(100,150,255,0.1)',
          border: `1px solid ${status.type==='success' ? 'rgba(0,255,100,0.3)' : status.type==='error' ? 'rgba(255,0,0,0.3)' : 'rgba(100,150,255,0.3)'}`,
          color: status.type==='success' ? '#00ff64' : status.type==='error' ? '#ff5555' : '#6496ff'
        }}>
          {status.message}
        </div>
      )}

      <div id="privy-iframe-container" style={{ marginTop: 20, minHeight: 600 }}>
        {/* Privy embedded wallet iframe appears here */}
      </div>
    </div>
  );
}
